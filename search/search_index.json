{"config":{"lang":["en"],"separator":"[\\s\\-]+","pipeline":["stopWordFilter"]},"docs":[{"location":"","title":"Workshop 02 - Data Quality","text":"<p>Para desenvolver o desafio de negocio, vamos montar a seguinte ETL</p>"},{"location":"#fluxo","title":"Fluxo","text":"<pre><code>graph TD;\n    A[Configura Vari\u00e1veis] --&gt; B[Ler o Banco SQL];\n    B --&gt; V[Valida\u00e7\u00e3o do Schema de Entrada];\n    V --&gt;|Falha| X[Alerta de Erro];\n    V --&gt;|Sucesso| C[Transformar os KPIs];\n    C --&gt; Y[Valida\u00e7\u00e3o do Schema de Sa\u00edda];\n    Y --&gt;|Falha| Z[Alerta de Erro];\n    Y --&gt;|Sucesso| D[Salvar no DuckDB];\n</code></pre>"},{"location":"#contrado-de-dados","title":"Contrado de dados","text":"<p>               Bases: <code>DataFrameModel</code></p> <p>Validation schema for product data using Pandera.</p> <p>This class defines validation rules for a DataFrame containing product information. Each column is typed and validated with specific constraints to ensure data integrity.</p> <p>Attributes:</p> Name Type Description <code>id_produto</code> <code>int</code> <p>Product identifier.</p> <code>nome</code> <code>str</code> <p>Product name. This field is required.</p> <code>quantidade</code> <code>int</code> <p>Product quantity in stock, must be between 20 and 200.</p> <code>preco</code> <code>float</code> <p>Product price, must be between 5.0 and 120.0. This field is required.</p> <code>categoria</code> <code>str</code> <p>Product category. This field is required.</p> Config <p>coerce (bool): Automatically casts column types to those defined in the schema.</p> Source code in <code>app\\schemas.py</code> <pre><code>class ProdutoSchema(pa.DataFrameModel):\n    \"\"\"\n    Validation schema for product data using Pandera.\n\n    This class defines validation rules for a DataFrame containing product\n    information. Each column is typed and validated with specific constraints\n    to ensure data integrity.\n\n    Attributes:\n        id_produto (int): Product identifier.\n        nome (str): Product name. This field is required.\n        quantidade (int): Product quantity in stock, must be between 20 and 200.\n        preco (float): Product price, must be between 5.0 and 120.0. This field is required.\n        categoria (str): Product category. This field is required.\n\n    Config:\n        coerce (bool): Automatically casts column types to those defined in the schema.\n    \"\"\"\n\n    id_produto: Series[int]\n    nome: Series[str] = pa.Field(nullable=False)\n    quantidade: Series[int] = pa.Field(ge=20, le=200)\n    preco: Series[float] = pa.Field(ge=05.0, le=120.0, nullable=False)\n    categoria: Series[str] = pa.Field(nullable=False)\n\n    class Config:\n        coerce = True\n</code></pre> <p>               Bases: <code>ProdutoSchema</code></p> <p>Validation schema for product data KPI using Pandera.</p> <p>This class defines validation rules for a DataFrame containing product information. Each column is typed and validated with specific constraints to ensure data integrity.</p> <p>Attributes:</p> Name Type Description <code>valor_total_estoque</code> <code>float</code> <p>Store total values, must be start 0.0. This field is required.</p> <code>categoria_normalizada</code> <code>str</code> <p>Normalized Category. This field is required.</p> <code>disponibilidade</code> <code>bool</code> <p>Availability Status.</p> Config <p>coerce (bool): Automatically casts column types to those defined in the schema.</p> Source code in <code>app\\schemas.py</code> <pre><code>class ProdutoSchemaKPI(ProdutoSchema):\n    \"\"\"\n    Validation schema for product data KPI using Pandera.\n\n    This class defines validation rules for a DataFrame containing product\n    information. Each column is typed and validated with specific constraints\n    to ensure data integrity.\n\n    Attributes:\n        valor_total_estoque (float): Store total values, must be start 0.0. This field is required.\n        categoria_normalizada (str): Normalized Category. This field is required.\n        disponibilidade (bool): Availability Status.\n\n    Config:\n        coerce (bool): Automatically casts column types to those defined in the schema.\n    \"\"\"\n\n    valor_total_estoque: Series[float] = pa.Field(ge=0)\n    categoria_normalizada: Series[str]\n    disponibilidade: Series[bool]\n</code></pre>"},{"location":"#carrega-configuracoes","title":"Carrega Configura\u00e7\u00f5es","text":"<p>Load settings with environment variables</p> Source code in <code>app\\etl.py</code> <pre><code>def load_settings():\n  \"\"\"\n  Load settings with environment variables\n  \"\"\"\n  dotenv_path = Path.cwd() / '.env'\n  load_dotenv(dotenv_path=dotenv_path)\n\n  settings = {\n    \"db_host\": os.getenv(\"POSTGRES_HOST\"),\n    \"db_user\": os.getenv(\"POSTGRES_USER\"),\n    \"db_pass\": os.getenv(\"POSTGRES_PASSWORD\"),\n    \"db_name\": os.getenv(\"POSTGRES_DB\"),\n    \"db_port\": os.getenv(\"POSTGRES_PORT\"),\n  }\n  return settings\n</code></pre>"},{"location":"#le-o-banco-sql","title":"L\u00ea o Banco SQL","text":"<p>Extrai dados do banco de dados SQL usando uma consulta fornecida.</p> <p>Parameters:</p> Name Type Description Default <code>query</code> <code>str</code> <p>A consulta SQL para extrair dados.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Um DataFrame do Pandas contendo os dados extraidos.</p> Source code in <code>app\\etl.py</code> <pre><code>@pa.check_output(ProdutoSchema.to_schema(), lazy=True)\ndef extrair_do_sql(query: str) -&gt; pd.DataFrame:\n    \"\"\"\n    Extrai dados do banco de dados SQL usando uma consulta fornecida.\n\n    Args: \n      query: A consulta SQL para extrair dados.\n\n    Returns: \n      Um DataFrame do Pandas contendo os dados extraidos.\n    \"\"\"\n\n    settings = load_settings()\n\n    #Criar a string de conex\u00e3o com base nas configura\u00e7\u00f5es\n    connection_string = f\"postgresql://{settings['db_user']}:{settings['db_pass']}@{settings['db_host']}:{settings['db_port']}/{settings['db_name']}\"\n\n    engine = create_engine(connection_string)\n\n    with engine.connect() as conn, conn.begin():\n          df_crm = pd.read_sql(query, conn)\n\n    return df_crm          \n</code></pre>"},{"location":"#transforma-os-kpi","title":"Transforma os KPI","text":"<p>Transforma dados da consulta SQL fornecida.</p> <p>Parameters:</p> Name Type Description Default <code>DataFrame</code> <p>O DataFrame da consulta fornecida.</p> required <p>Returns:</p> Type Description <code>DataFrame</code> <p>Um DataFrame do Pandas contendo os dados transformados.</p> Source code in <code>app\\etl.py</code> <pre><code>@pa.check_input(ProdutoSchema.to_schema(), lazy=True)\n@pa.check_output(ProdutoSchemaKPI.to_schema(), lazy=True)\ndef transformar(df: pd.DataFrame) -&gt; pd.DataFrame:\n     \"\"\"\n     Transforma dados da consulta SQL fornecida.\n\n    Args: \n      DataFrame: O DataFrame da consulta fornecida.\n\n    Returns: \n      Um DataFrame do Pandas contendo os dados transformados.\n     \"\"\"\n\n     #Calcular valor_total_estoque\n     df['valor_total_estoque'] = df['quantidade'] * df['preco']\n\n     #Normalizar categoria para maiusculas\n     df['categoria_normalizada'] = df['categoria'].str.upper()\n\n     #Determinar disponibilidade (True se quantidade &gt; 0)\n     df['disponibilidade'] = df['quantidade'] &gt; 0 \n\n     return df\n</code></pre>"},{"location":"#salvar-dados-para-o-duckdb","title":"Salvar dados para o DuckDB","text":"<p>Carrega o DataFrame no DuckDB, criando ou substituindo a tabela especifica</p> <p>Parameters:</p> Name Type Description Default <code>df</code> <code>DataFrame</code> <p>DataFrame do Pandas para ser carregado ao DuckDB</p> required <code>table_name</code> <p>Nome da tabela no DuckDB onde os dados ser\u00e3o inseridos.</p> required <code>db_file</code> <code>str</code> <p>Caminho para o arquivo. Se n\u00e3o existir, ser\u00e1 criado.</p> <code>'sql/my_duckdb.db'</code> Source code in <code>app\\etl.py</code> <pre><code>@pa.check_input(ProdutoSchemaKPI.to_schema(), lazy=True)\ndef load_to_duckdb(df:pd.DataFrame, tablename:str, db_file:str = 'sql/my_duckdb.db'):\n     \"\"\"\n     Carrega o DataFrame no DuckDB, criando ou substituindo a tabela especifica\n\n     Args: \n        df: DataFrame do Pandas para ser carregado ao DuckDB\n        table_name: Nome da tabela no DuckDB onde os dados ser\u00e3o inseridos.\n        db_file: Caminho para o arquivo. Se n\u00e3o existir, ser\u00e1 criado.     \n     \"\"\"\n     #Conectar ao DuckDB. Se o arquivos n\u00e3o existir, ele ser\u00e1 criado.\n     con = duckdb.connect(database=db_file, read_only=False)\n\n     #Registrar o DataFrame como uma tabela tempor\u00e1ria\n     con.register('df_temp', df)\n\n     # Utilizar SQL para inserir os dados da tabela tempor\u00e1ria em uma tabela\n     # Se a tabela j\u00e1 existir, substitui.\n     con.execute(f\"CREATE OR REPLACE TABLE {tablename} AS SELECT * FROM df_temp\")\n\n     # Fechar a conex\u00e3o\n     con.close()\n</code></pre>"}]}